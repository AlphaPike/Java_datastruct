## 暴力递归

#### 总体思路：

1. 将问题转换为规模更小的同类问题的子问题（子问题再通过转换成规模更小的子问题）
2. 有明确的不需要继续进行的递归的条件（当子问题小到一定程度之后的base case（边界条件）就是原问题的解）
3. 有当得到了子问题的结果之后的决策过程（将子问题解决之后，如何返回去解决原来的问题）
4. 不记录每一个子问题的解



## 汉诺塔问题

- 问题：存在三个柱子，分别是左，中，右，左柱子上存在从高到低一叠盘子，每次移动一个盘子，移动到右盘上，并且保证下方的盘子永远大于上方的盘子

- 思路：
  - 总：想要将第i个盘移动到右侧柱子上，就是想办法把i-1个盘移动到中间柱子上，然后将第i个盘移动到右侧柱子上，然后将之前i-1个盘移动到右侧柱子上
  - 规模更小的同类子问题：对于i-1个盘的移动就是相近的规模更小的子问题，而解决这个规模更小的子问题的方法就是再次调用递归函数的过程（所以可以简单理解成这个函数本身就是一个黑箱）
  - 由于是直接打印这个节点所以没有决策过程

- 代码：

  ```java
  class Hanno {
      private static void print(String from, String to) {
          System.out.println("将盘子从" + from + "移动到" + to);
      }
  
      public static void func(int i, String from, String to, String other) {
          if(i == 1) {
              print(from, to);
              return ;
          }
          func(i - 1, from, other, to);
          print(from, to);
          func(i - 1, other, to, from);
      }
  }
  ```

  

## N皇后问题

#### 思路：

- 总：暴力解法，使用深度优先遍历，确定所有当前层数皇后的位置，对于每一个位置递归调用获得后几层皇后的位置的所有可能性
- 判断是否符合位置要求：如果两点的水平距离和两点的垂直距离相等说明不满足要求

#### 代码：

![image-20230303192211595](D:\笔记_Node\source-images\image-20230303192211595.png)

#### 常数优化（了解）：

- 思路：
  - 总：使用进制代替皇后，进制中1表示当前位置为不符合要求的位置
  - 推算不符合要求的位置：使用左右移动，左移表示左边斜线的方向不能占有皇后，右移表示右边斜向的位置上不能占有皇后
- 代码：

![image-20230303194231213](D:\笔记_Node\source-images\image-20230303194231213.png)

- 总结：使用二进制+左移、右移可以减少时间复杂度