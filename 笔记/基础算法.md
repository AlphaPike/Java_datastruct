## 时间复杂度

- 计算方法：**在最差情况下**，常数操作数量的表达式只保留最高阶项且去掉其系数，记作o(_)
- 常数级别的时间复杂度
- 递归的时间复杂度：maser公式：T(N) = a*T(N/b) + o(N)
  - （粗略估计：一次调用记为o(1)）



## 对分查找

- 时间复杂度：o(log N)
- 需要掌握的题型：
  1. 边界问题：当等于结果值时是左指针移动还是右指针移动
  2. 局部最小值问题：



## 排序

- 归并排序：
  - 思路：将提供的两组有序数组归并成更大的有序数组
  - 题型：小和问题/逆序对问题

- 快速排序：
  - 引出：波兰旗问题
  - 思路：确定每个数的绝对位置，从而确定数组的顺序
- 优先队列/堆：
- 排序算法的选择：
  - 快排：速度最快（o(N*log N) 的常数项最小，一般的选择）
  - 归并：稳定性最好
  - 堆排序：空间复杂度最低（o(1)）

- 关于Arrays.sort()：在提供的基础数时使用的快速排序，在提供的是非基础数时使用归并排序以保证稳定性



## 高精度



#### 前言

由于在C++中不包含高精度对象，所以需要通过高精度算法计算

#### A + B

- 大整数的存储：逆序存入数组中
- 思路：模拟竖式

